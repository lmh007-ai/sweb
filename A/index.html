<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TO：梁梦诗小朋友~ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Microsoft Yahei', Arial, sans-serif;
        }

        #fireworkCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .textCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }

        .countdown-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            text-align: center;
            opacity: 0;
            pointer-events: none;
        }

        .countdown {
            font-size: clamp(4rem, 15vw, 10rem);
            font-weight: bold;
            color: #fff;
            text-shadow: 
                0 0 10px #fff,
                0 0 20px #fff,
                0 0 40px #ffd700,
                0 0 80px #ffd700,
                0 0 120px #ffd700;
            margin-bottom: 2rem;
        }

        .happy-new-year {
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: bold;
            background: linear-gradient(90deg, #ff0000, #ffa500, #ffff00, #00ff00, #0000ff, #800080);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-stroke: 2px transparent;
            animation: gradient 3s ease infinite;
            position: relative;
        }

        .happy-new-year::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
            -webkit-text-stroke: 3px;
            -webkit-text-stroke-color: transparent;
            background: linear-gradient(90deg, #ff0000, #ffa500, #ffff00, #00ff00, #0000ff, #800080);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .hidden {
            display: none;
        }

        /* 开始按钮样式 - 全屏覆盖，居中 */
        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }

        #startButton {
            font-size: clamp(2rem, 10vw, 5rem);
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            padding: 20px 60px;
            border-radius: 60px;
            box-shadow: 0 0 30px rgba(255,75,43,0.8);
            animation: pulse 1.5s infinite;
            transition: transform 0.3s;
            border: 3px solid #fff;
            letter-spacing: 4px;
        }

        #startButton:hover {
            transform: scale(1.1);
            background: linear-gradient(45deg, #ff4b2b, #ff416c);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px #ff416c; }
            50% { box-shadow: 0 0 60px #ff4b2b; }
            100% { box-shadow: 0 0 20px #ff416c; }
        }

        /* 原有audio隐藏 */
        audio {
            display: none;
        }

        .tip-window {
            position: fixed;
            padding: 20px;
            border-radius: 20px;
            font-family: "微软雅黑", sans-serif;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
            box-sizing: border-box;
            z-index: 20;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- 开始按钮覆盖层 -->
    <div id="startOverlay">
        <div id="startButton">✨ 开始 ✨</div>
    </div>

    <canvas id="fireworkCanvas"></canvas>
    <canvas class="textCanvas"></canvas>
    
    <div class="countdown-container">
        <div id="countdown" class="countdown"></div>
        <div id="happyNewYear" class="happy-new-year hidden" data-text="2026新年快乐!">2026新年快乐!</div>
    </div>

    <!-- 背景音乐：相对路径 peiyin.MP3，无控制面板，初始不自动播放 -->
    <audio id="bgMusic" preload="auto">
        <source src="peiyin.MP3" type="audio/mpeg">
    </audio>

    <script>
        // ===================== 全局控制标志 =====================
        window.firstPhaseActive = true; // 第一阶段是否运行

        // ===================== 原烟花特效代码 =====================
        const fireworkController = {
            isActive: true,
            stopTimer: null,
            stopDelay: 8000,
            stopFireworks() {
                this.stopTimer = setTimeout(() => {
                    this.isActive = false;
                    console.log('烟花效果将在现有粒子消散后停止');
                }, this.stopDelay);
            },
            clearStopTimer() {
                if (this.stopTimer) {
                    clearTimeout(this.stopTimer);
                    this.stopTimer = null;
                }
            }
        };

        const canvas = document.getElementById('fireworkCanvas');
        const ctx = canvas.getContext('2d');
        const countdownEl = document.getElementById('countdown');
        const happyNewYearEl = document.getElementById('happyNewYear');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const COLORS = [
            '#ff0000', '#ffa500', '#ffff00', '#00ff00',
            '#0000ff', '#800080', '#ffc0cb', '#00ffff'
        ];

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.1;
                this.alpha = 1;
                this.decay = Math.random() * 0.01 + 0.005;
            }
            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.alpha -= this.decay;
            }
            draw() {
                if (this.alpha <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Firework {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height;
                this.targetY = Math.random() * canvas.height / 2 + 50;
                this.speed = Math.random() * 6 + 6;
                this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                this.state = 0;
                this.particles = [];
            }
            update() {
                if (this.state === 0) {
                    this.y -= this.speed;
                    if (this.y <= this.targetY) {
                        this.state = 1;
                        const particleCount = Math.floor(Math.random() * 100 + 100);
                        for (let i = 0; i < particleCount; i++) {
                            this.particles.push(new Particle(this.x, this.y, this.color));
                        }
                    }
                } else if (this.state === 1) {
                    let allDead = true;
                    this.particles.forEach(particle => {
                        particle.update();
                        if (particle.alpha > 0) allDead = false;
                    });
                    if (allDead) this.state = 2;
                }
            }
            draw() {
                if (this.state === 0) {
                    ctx.save();
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, canvas.height);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                    ctx.restore();
                } else if (this.state === 1) {
                    this.particles.forEach(particle => particle.draw());
                }
            }
        }

        let fireworks = [];

        function createFirework() {
            if (fireworkController.isActive && Math.random() < 0.1) {
                fireworks.push(new Firework());
            }
        }

        function animateFirework() {
            if (!window.firstPhaseActive) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            createFirework();

            fireworks = fireworks.filter(firework => {
                firework.update();
                firework.draw();
                return firework.state !== 2;
            });

            requestAnimationFrame(animateFirework);
        }

        // ===================== 粒子文字特效 =====================
        var S = {
            init: function () {
                S.Drawing.init('.textCanvas');
                document.body.classList.add('body--ready');
                
                const countdownTime = 5;
                let sequence = [`|#countdown ${countdownTime}||2026|新年快乐|凡是过往|皆为序章|福起新岁|万事顺遂|下一个365天|也要充满热爱|`];
                S.UI.simulate(sequence[0]);

                S.Drawing.loop(function () {
                    S.Shape.render();
                });
            }
        };

        S.Drawing = (function () {
            var canvas,
                context,
                renderFn,
                requestFrame = window.requestAnimationFrame ||
                               window.webkitRequestAnimationFrame ||
                               window.mozRequestAnimationFrame ||
                               window.oRequestAnimationFrame ||
                               window.msRequestAnimationFrame ||
                               function(callback) {
                                   window.setTimeout(callback, 1000 / 60);
                               };

            return {
                init: function (el) {
                    canvas = document.querySelector(el);
                    context = canvas.getContext('2d');
                    this.adjustCanvas();

                    window.addEventListener('resize', function (e) {
                        S.Drawing.adjustCanvas();
                    });
                },

                loop: function (fn) {
                    renderFn = !renderFn ? fn : renderFn;
                    if (!window.firstPhaseActive) return;
                    this.clearFrame();
                    renderFn();
                    requestFrame.call(window, this.loop.bind(this));
                },

                adjustCanvas: function () {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                },

                clearFrame: function () {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                },

                getArea: function () {
                    return { w: canvas.width, h: canvas.height };
                },

                drawCircle: function (p, c) {
                    context.fillStyle = c.render();
                    context.beginPath();
                    context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
                    context.closePath();
                    context.fill();
                }
            }
        }());

        S.UI = (function () {
            var canvas = document.querySelector('.textCanvas'),
                interval,
                currentAction,
                maxShapeSize = 30,
                sequence = [],
                cmd = '#';

            function formatTime(date) {
                var h = date.getHours(),
                    m = date.getMinutes();
                m = m < 10 ? '0' + m : m;
                return h + ':' + m;
            }

            function getValue(value) {
                return value && value.split(' ')[1];
            }

            function getAction(value) {
                value = value && value.split(' ')[0];
                return value && value[0] === cmd && value.substring(1);
            }

            function timedAction(fn, delay, max, reverse) {
                clearInterval(interval);
                currentAction = reverse ? max : 1;
                fn(currentAction);

                if (!max || (!reverse && currentAction < max) || (reverse && currentAction > 0)) {
                    interval = setInterval(function () {
                        currentAction = reverse ? currentAction - 1 : currentAction + 1;
                        fn(currentAction);

                        if ((!reverse && max && currentAction === max) || (reverse && currentAction === 0)) {
                            clearInterval(interval);
                        }
                    }, delay);
                }
            }

            function reset(destroy) {
                clearInterval(interval);
                sequence = [];
                destroy && S.Shape.switchShape(S.ShapeBuilder.letter(''));
            }

            function performAction(value) {
                var action,
                    value,
                    current;

                sequence = typeof(value) === 'object' ? value : sequence.concat(value.split('|'));
                const totalSequenceLength = sequence.length;

                timedAction(function (index) {
                    current = sequence.shift();
                    action = getAction(current);
                    value = getValue(current);

                    switch (action) {
                        case 'countdown':
                            value = parseInt(value) || 10;
                            value = value > 0 ? value : 10;

                            timedAction(function (index) {
                                if (index === 0) {
                                    setInterval(() => {
                                        if (fireworkController.isActive && Math.random() < 0.5) {
                                            fireworks.push(new Firework());
                                        }
                                    }, 200);
                                    
                                    if (sequence.length === 0) {
                                        S.Shape.switchShape(S.ShapeBuilder.letter(''));
                                    } else {
                                        performAction(sequence);
                                    }
                                } else {
                                    S.Shape.switchShape(S.ShapeBuilder.letter(index), true);
                                    if (fireworkController.isActive && Math.random() < 0.2) {
                                        fireworks.push(new Firework());
                                    }
                                }
                            }, 1000, value, true);
                            break;

                        case 'rectangle':
                            value = value && value.split('x');
                            value = (value && value.length === 2) ? value : [maxShapeSize, maxShapeSize / 2];
                            S.Shape.switchShape(S.ShapeBuilder.rectangle(Math.min(maxShapeSize, parseInt(value[0])), Math.min(maxShapeSize, parseInt(value[1]))));
                            break;

                        case 'circle':
                            value = parseInt(value) || maxShapeSize;
                            value = Math.min(value, maxShapeSize);
                            S.Shape.switchShape(S.ShapeBuilder.circle(value));
                            break;

                        case 'time':
                            var t = formatTime(new Date());
                            if (sequence.length > 0) {
                                S.Shape.switchShape(S.ShapeBuilder.letter(t));
                            } else {
                                timedAction(function () {
                                    t = formatTime(new Date());
                                    S.Shape.switchShape(S.ShapeBuilder.letter(t));
                                }, 1000);
                            }
                            break;

                        default:
                            if (current[0] !== cmd) {
                                if (fireworkController.isActive && Math.random() < 0.3) {
                                    fireworks.push(new Firework());
                                }
                            }
                            S.Shape.switchShape(S.ShapeBuilder.letter(current[0] === cmd ? 'Happy New Year!' : current));
                    }

                    // 所有序列播放完毕，5秒后切换飘字
                    if (sequence.length === 0 && index === totalSequenceLength) {
                        console.log('所有祝福文字播放完毕，5秒后切换飘字');
                        setTimeout(() => {
                            switchToLoveEffect();
                        }, 5000);
                    }
                }, 2000, sequence.length);
            }

            return {
                simulate: function (action) {
                    performAction(action);
                }
            }
        }());

        // ... (S.Point, S.Color, S.Dot, S.ShapeBuilder, S.Shape 等代码保持不变)
        S.Point = function(args){this.x=args.x;this.y=args.y;this.z=args.z;this.a=args.a;this.h=args.h;};
        S.Color = function(r,g,b,a){this.r=r;this.g=g;this.b=b;this.a=a;};
        S.Color.prototype.render=function(){return 'rgba('+this.r+','+this.g+','+this.b+','+this.a+')';};
        S.Dot = function(x,y){this.p=new S.Point({x:x,y:y,z:5,a:1,h:0});this.e=0.07;this.s=true;this.c=new S.Color(255,255,255,this.p.a);this.t=this.clone();this.q=[];};
        S.Dot.prototype={clone:function(){return new S.Point({x:this.x,y:this.y,z:this.z,a:this.a,h:this.h});},_draw:function(){this.c.a=this.p.a;S.Drawing.drawCircle(this.p,this.c);},_moveTowards:function(n){var details=this.distanceTo(n,true),dx=details[0],dy=details[1],d=details[2],e=this.e*d;if(this.p.h===-1){this.p.x=n.x;this.p.y=n.y;return true;}if(d>1){this.p.x-=((dx/d)*e);this.p.y-=((dy/d)*e);}else{if(this.p.h>0){this.p.h--;}else{return true;}}return false;},_update:function(){if(this._moveTowards(this.t)){var p=this.q.shift();if(p){this.t.x=p.x||this.p.x;this.t.y=p.y||this.p.y;this.t.z=p.z||this.p.z;this.t.a=p.a||this.p.a;this.p.h=p.h||0;}else{if(this.s){this.p.x-=Math.sin(Math.random()*3.142);this.p.y-=Math.sin(Math.random()*3.142);}else{this.move(new S.Point({x:this.p.x+(Math.random()*50)-25,y:this.p.y+(Math.random()*50)-25,}));}}}d=this.p.a-this.t.a;this.p.a=Math.max(0.1,this.p.a-(d*0.05));d=this.p.z-this.t.z;this.p.z=Math.max(1,this.p.z-(d*0.05));},distanceTo:function(n,details){var dx=this.p.x-n.x,dy=this.p.y-n.y,d=Math.sqrt(dx*dx+dy*dy);return details?[dx,dy,d]:d;},move:function(p,avoidStatic){if(!avoidStatic||(avoidStatic&&this.distanceTo(p)>1)){this.q.push(p);}},render:function(){this._update();this._draw();}};
        S.ShapeBuilder = (function(){var gap=13,shapeCanvas=document.createElement('canvas'),shapeContext=shapeCanvas.getContext('2d'),fontSize=500,fontFamily='Microsoft Yahei, Avenir, Helvetica Neue, Helvetica, Arial, sans-serif';function fit(){shapeCanvas.width=Math.floor(window.innerWidth/gap)*gap;shapeCanvas.height=Math.floor(window.innerHeight/gap)*gap;shapeContext.fillStyle='red';shapeContext.textBaseline='middle';shapeContext.textAlign='center';}function processCanvas(){var pixels=shapeContext.getImageData(0,0,shapeCanvas.width,shapeCanvas.height).data;var dots=[],x=0,y=0,fx=shapeCanvas.width,fy=shapeCanvas.height,w=0,h=0;for(var p=0;p<pixels.length;p+=(4*gap)){if(pixels[p+3]>0){dots.push(new S.Point({x:x,y:y}));w=x>w?x:w;h=y>h?y:h;fx=x<fx?x:fx;fy=y<fy?y:fy;}x+=gap;if(x>=shapeCanvas.width){x=0;y+=gap;p+=gap*4*shapeCanvas.width;}}return{dots:dots,w:w+fx,h:h+fy};}function setFontSize(s){shapeContext.font='bold '+s+'px '+fontFamily;}function isNumber(n){return!isNaN(parseFloat(n))&&isFinite(n);}function init(){fit();window.addEventListener('resize',fit);}init();return{circle:function(d){var r=Math.max(0,d)/2;shapeContext.clearRect(0,0,shapeCanvas.width,shapeCanvas.height);shapeContext.beginPath();shapeContext.arc(r*gap,r*gap,r*gap,0,2*Math.PI,false);shapeContext.fill();shapeContext.closePath();return processCanvas();},letter:function(l){var s=0;setFontSize(fontSize);s=Math.min(fontSize,(shapeCanvas.width/shapeContext.measureText(l).width)*0.8*fontSize,(shapeCanvas.height/fontSize)*(isNumber(l)?1:0.45)*fontSize);setFontSize(s);shapeContext.clearRect(0,0,shapeCanvas.width,shapeCanvas.height);shapeContext.fillText(l,shapeCanvas.width/2,shapeCanvas.height/2);return processCanvas();},rectangle:function(w,h){var dots=[],width=gap*w,height=gap*h;for(var y=0;y<height;y+=gap){for(var x=0;x<width;x+=gap){dots.push(new S.Point({x:x,y:y}));}}return{dots:dots,w:width,h:height};}};}());
        S.Shape = (function(){var dots=[],width=0,height=0,cx=0,cy=0;function compensate(){var a=S.Drawing.getArea();cx=a.w/2-width/2;cy=a.h/2-height/2;}return{shuffleIdle:function(){var a=S.Drawing.getArea();for(var d=0;d<dots.length;d++){if(!dots[d].s){dots[d].move({x:Math.random()*a.w,y:Math.random()*a.h});}}},switchShape:function(n,fast){var size,a=S.Drawing.getArea();width=n.w;height=n.h;compensate();if(n.dots.length>dots.length){size=n.dots.length-dots.length;for(var d=1;d<=size;d++){dots.push(new S.Dot(a.w/2,a.h/2));}}var d=0,i=0;while(n.dots.length>0){i=Math.floor(Math.random()*n.dots.length);dots[d].e=fast?0.25:(dots[d].s?0.14:0.11);if(dots[d].s){dots[d].move(new S.Point({z:Math.random()*20+10,a:Math.random(),h:18}));}else{dots[d].move(new S.Point({z:Math.random()*5+5,h:fast?18:30}));}dots[d].s=true;dots[d].move(new S.Point({x:n.dots[i].x+cx,y:n.dots[i].y+cy,a:1,z:5,h:0}));n.dots=n.dots.slice(0,i).concat(n.dots.slice(i+1));d++;}for(var i=d;i<dots.length;i++){if(dots[i].s){dots[i].move(new S.Point({z:Math.random()*20+10,a:Math.random(),h:20}));dots[i].s=false;dots[i].e=0.04;dots[i].move(new S.Point({x:Math.random()*a.w,y:Math.random()*a.h,a:0.3,z:Math.random()*4,h:0}));}}},render:function(){for(var d=0;d<dots.length;d++){dots[d].render();}}};}());

        // ===================== 飘字特效（优化版：每个词出现两次，随机顺序） =====================
        function startLoveEffect() {
            const tips = [
                '多喝水哦~', '保持微笑呀', '每天都要元气满满', '记得吃水果', 
                '保持好心情', '好好爱自己', '早点休息', '事事都顺心', 
                '对自己好一点', '做个快乐的小朋友', '愿你被温柔以待', 
                '梦想成真', '期待下一次见面', '天冷了，多穿衣服', 
                '愿所有烦恼都消失', '累了就歇一歇', '生活甜甜好运连连', 
                '保持好心情', '今天也要加油呀', '好好吃饭', '别熬夜'
            ];
            const bgColors = [
                '#ff99cc', '#88ccff', '#99e699', '#cc99ff', '#ffff99', 
                '#ff9999', '#ffcc99', '#99ffff', '#ffcce6', '#e6ffcc', '#ffb3e6'
            ];

            // 将每个提示语复制两次，并打乱顺序
            let doubledTips = [];
            tips.forEach(tip => doubledTips.push(tip, tip)); // 每个出现两次
            // Fisher-Yates 洗牌算法打乱数组
            for (let i = doubledTips.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [doubledTips[i], doubledTips[j]] = [doubledTips[j], doubledTips[i]];
            }

            const windowCount = doubledTips.length; // 自动等于 tips.length * 2
            const windowWidth = 600;
            const windowHeight = 200;
            let tipIndex = 0; // 当前显示到第几个

            function createTipWindow() {
                const tip = doubledTips[tipIndex % doubledTips.length];
                tipIndex++;
                const bg = bgColors[Math.floor(Math.random() * bgColors.length)];

                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const maxX = screenWidth - windowWidth;
                const maxY = screenHeight - windowHeight;
                const x = maxX > 0 ? Math.random() * maxX : 0;
                const y = maxY > 0 ? Math.random() * maxY : 0;

                const tipWindow = document.createElement('div');
                tipWindow.className = 'tip-window';
                tipWindow.style.width = `${windowWidth}px`;
                tipWindow.style.height = `${windowHeight}px`;
                tipWindow.style.left = `${x}px`;
                tipWindow.style.top = `${y}px`;
                tipWindow.style.backgroundColor = bg;

                tipWindow.innerHTML = `
                    <div style="
                        font-size: 60px;
                        font-weight: 900;
                        line-height: ${windowHeight}px;
                        color: #222;
                        letter-spacing: 2px;
                    ">${tip}</div>
                `;

                document.body.appendChild(tipWindow);

                setTimeout(() => {
                    tipWindow.style.opacity = '0';
                    tipWindow.style.transition = 'opacity 0.8s ease-in-out';
                    setTimeout(() => {
                        if (tipWindow.parentNode) document.body.removeChild(tipWindow);
                    }, 800);
                }, 5000);
            }

            // 每隔350ms创建一个窗口，直到达到总数
            const interval = setInterval(() => {
                if (tipIndex < windowCount) {
                    createTipWindow();
                } else {
                    clearInterval(interval);
                }
            }, 350);

            // 窗口大小变化时重新生成（保持原有逻辑）
            function resizeHandler() {
                document.querySelectorAll('.tip-window').forEach(win => win.remove());
                tipIndex = 0;
                clearInterval(interval);
                const newInterval = setInterval(() => {
                    if (tipIndex < windowCount) {
                        createTipWindow();
                    } else {
                        clearInterval(newInterval);
                    }
                }, 350);
            }
            window.addEventListener('resize', resizeHandler);
        }

        // ===================== 切换函数 =====================
        function switchToLoveEffect() {
            window.firstPhaseActive = false;
            fireworkController.isActive = false;

            document.getElementById('fireworkCanvas').style.display = 'none';
            document.querySelector('.textCanvas').style.display = 'none';
            document.querySelector('.countdown-container').style.display = 'none';

            startLoveEffect();
        }

        // ===================== 开始按钮逻辑 =====================
        const startOverlay = document.getElementById('startOverlay');
        startOverlay.addEventListener('click', function() {
            // 移除开始按钮
            startOverlay.style.display = 'none';

            // 播放音乐（用户手势确保成功）
            const music = document.getElementById('bgMusic');
            music.play().catch(err => console.log('音乐播放失败:', err));

            // 启动烟花动画
            animateFirework();

            // 5秒后启动粒子文字（保持原有时序）
            setTimeout(() => {
                S.init();
            }, 5000);

            // 可选：添加键盘触发烟花的功能（保持不变）
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && fireworkController.isActive) {
                    fireworks.push(new Firework());
                }
            });
        });

        // 注意：原代码中 animateFirework() 和 setTimeout(S.init,5000) 已被移除，全部由按钮触发
        // 原 window.onload 中的音乐自动播放逻辑也移除，因为现在由按钮控制
    </script>
</body>
</html>